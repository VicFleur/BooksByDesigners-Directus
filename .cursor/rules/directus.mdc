---
description: "A quick-reference to work with a Directus codebase that contains custom extensions."
globs: ["**/*.js"]
alwaysApply: true
---


## 1. Extension Types
• **API** (server runtime)
  – Hooks `filter | action | init | schedule | embed`
  – Endpoints (Express router at `/<id>`)
  – Operations (`app.ts` + `api.ts`) for Flows
• **App** (Data Studio, Vue 3)
  – Interfaces, Displays, Layouts, Panels, Modules, Themes
• **Bundles/Marketplace** wrap multiple extensions; same rules apply per entry.

## 2. Naming & UIDs
• One folder per extension, kebab-case (`my-endpoint`).
• Each entrypoint exports `id` **unique project-wide**; for operations both `app` and `api` ids must match.
• Package.json must include:
```json
"directus:extension": {
  "type": "endpoint|hook|interface|…",
  "path": "dist/index.js",
  "source": "src/index.ts",
  "host": "^10.x"  // directus peer version
}
```
• Generated by `npx create-directus-extension@latest`.

## 3. Build & Hot-Reload
• Build with `npm run build` (uses tsup / vite depending on type).
• Dev mode `npm run dev` + env `EXTENSIONS_AUTO_RELOAD=true` reloads without restart.
• Server loads from `EXTENSIONS_PATH` (default `./extensions`) or a storage `EXTENSIONS_LOCATION`.
• Disable load-errors with `EXTENSIONS_MUST_LOAD=false`.

## 4. Server Runtime Context (API ext)
`(router|registerFn, context)` where
```ts
context = {
  services,        // ItemsService etc.
  database,        // Knex          
  getSchema,       // async () => Schema
  env, logger, emitter
}
```
Use services with `{ schema: await getSchema(), accountability }`.
Avoid infinite recursion: when service triggers same event pass `{ emitEvents:false }`.

## 5. Hooks Cheat-Sheet
```
filter('items.create', (payload, meta, ctx) => payload ) // blocking, modify/throw
action('items.create', (meta, ctx) => {})               // after event
init('routes.before', meta=>{})                         // lifecycle
schedule('*/5 * * * *',()=>{})                          // cron
embed('head'|'body', html)
```
Meta & ctx props listed above.  Filters run **before** default logic, can harm perf; use sparingly on `read`.  System collection exceptions: `collections/fields` lack `read`; `files` has no `create/update` on upload; `relations` no `delete`.

## 6. Sandbox Mode
Add `{ "sandbox": { "enabled": true, "requestedScopes": { … } } }` to package.json.
Only `filter`/`action` or Router handlers allowed.  Common scopes: `log`, `sleep`, `request { methods, urls }`.
No `console` or timers unless scope granted.

## 7. App Entrypoints
Use helpers from `@directus/extensions-sdk`:
```js
import { defineInterface | defineLayout | defineTheme } from '@directus/extensions-sdk'
```
General required props per type:
```
id, name, icon, description, component, options?, types?
```
Interfaces/Displays emit `input`; Layouts emit `update:*`; Panels get size props.  Module routes use Vue-Router syntax, base path = id.

## 7-bis. Query Patterns & Performance
### ItemsService Examples
```js
const items = new ItemsService('articles', { schema: await getSchema(), accountability });
const one = await items.readOne(id, { fields: ['title','status'] });
const list = await items.readByQuery({ limit:20, filter:{ status:{ _eq:'published'} }, sort:['-date_created'] });
await items.updateOne(id, { status:'archived' }, { emitEvents:false });
```
• Prefer `readByQuery` with `fields` subset to minimize payload.
• Use `_in`, `_contains`, `_between` etc.  Filters mirror REST query params.
• Wrap multiple DB ops in single transaction via `database.transaction` for atomicity.

### Deep/Nested Reads
Directus imposes an **automatic limit of 100 items per collection level**.  If you expect >100 items **always override the limit** with `limit:-1` at each `deep` level (or a numeric limit you choose).

```js
// Fetch article with unlimited comments and author
const article = await items.readOne(articleId, {
  fields: ['*', 'author.*', 'comments.*'],
  deep: {
    author: { // single m2o – limit ignored but add for clarity
      _limit: -1
    },
    comments: {
      _limit: -1, // >100? remove cap
      _sort: ['-date_created'],
      replies: {  // nested o2m within comments
        _limit: -1,
        author: { _limit: -1 }
      }
    }
  }
});
```
• `_limit: -1` disables the cap (same as REST `limit=-1`).
• Always include at **every level**; otherwise nested collections silently cut off at 100.
• Combine `_sort`, `_filter`, `_page` as needed.

### Filter Best-Practices
• Always clone/return payload in filters; mutate in place only when needed.
• Heavy `items.read` filters should offload expensive logic to DB queries instead of JS loops.
• For auth-sensitive filters, use `ctx.accountability.role` to conditionally block/modify.
• To abort action, throw a typed error from `@directus/errors` (eg `ForbiddenError`).

## 8. Common Footguns
• Forgetting to return/throw in Operation handler stops Flow chain.
• Blocking `filter` heavy `read`s – large perf hit.
• Infinite recursion when service call inside same event.
• Missing matching ids between `app` and `api` entrypoints.
• Non-unique id collisions across extensions.
• Bundled JS must stay ESM compatible with Node 18; avoid top-level await outside modules.

### Messaging Helpers
#### MailService (server)
```js
const { MailService } = context.services;
const mail = new MailService({
  schema: await getSchema(),
  accountability: null // send as system
});
await mail.send({
  to: 'user@example.com',
  subject: 'Welcome',
  template: 'welcome', // liquid template filename sans .liquid
  data: { name:'John' }
});
```
Liquid templates live in `extensions/mail/templates/*.liquid` and are processed with [liquidjs] syntax.  Use `{{ name }}` placeholders.

#### NotificationService (server)
```js
const { NotificationService } = context.services;
const notify = new NotificationService({ schema: await getSchema(), accountability });
await notify.createOne({
  recipient: userId,
  subject: 'Task Completed',
  message: 'Your task {{task}} is done', // liquid supported
  data: { task:'Import' }
});
```
Both services support Liquid variables – wrap keys in `{{ }}` and pass matching `data`.